When a client connects to a server over TLS (e.g. https), a TLS handshake is performed.
As part of the TLS handshake, the server sends a message to the client containing the server's TLS certificate.
Then, the client validates the certificate to ensure that the certificate can be trusted (i.e., that the certificate is signed by a trusted certificate authority) and that the certificate matches the domain the client is interacting with.
This process confirms that the server is who it claims to be and that the client is interacting with the real owner of the domain.

If the client does not validate the server's TLS certificate, this **significantly increases the risk that the client will fall victim to a Man in the Middle (MitM) attack**.
In this attack, an attacker secretly reads, relays, and possibly modifies the communications between the server and the client.
The two parties believe that they are directly communicating with each other, as the attacker has inserted themselves in the connection between the two parties.

A Man in the Middle attack poses a major security risk, as the attacker can then, for example, **harvest passwords or API keys, manipulate the content of web pages viewed by the client**, or, in case of online banking, **change the destination account number and transfer amount of a transfer**.

The TLS certificate validation is often disabled if a client should connect to a server that uses an untrusted self-signed certificate for which the validation fails.

In Python, the validation of TLS certificates is often disabled by using the functions in the `requests` module with `verify=False`:

<pre class="language-python line-numbers" data-line="4"><code>
import requests

url = "https://example.org"
result = requests.get(url, verify=False)
</code></pre>
